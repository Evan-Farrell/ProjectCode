from PIL import Image
import random
import numpy
import itertools
import functools

def permutate(height,length,img,mapping):
    #Get the size of the data saved in a pixel's coordinates
    pixel_data_size=len(img[0,0])

    #Initialize an array to store the permutation
    temp=numpy.full((height*length,pixel_data_size),[0]*pixel_data_size, dtype=list)

    #Flatten the 2-d coordinate plane to create the permutation of the image
    img=img.reshape((height*length),pixel_data_size)
    for x in range(0,height*length):
        temp[x]=img[mapping[x]]

    #Reconstruct the permutated array back into the dimensions of the image
    temp=temp.reshape(height,length,pixel_data_size)

    return temp

def apply_mask(height,length,mask,img):
    #Get the size of the data saved in a pixel's coordinates
    pixel_data_size=len(img[0,0])

    #Initialize an array to store the applied mask
    temp=numpy.full((height*length,pixel_data_size),[0]*pixel_data_size, dtype=list)

    #Flatten the 2-d coordinate plane to apply the masking to the image
    img=img.reshape((height*length),pixel_data_size)
    for i in range(0,height*length):
        for j in range(0,pixel_data_size):
            temp[i][j]=(img[i][j]+mask[i][j]) % 256

    #Reconstruct the permutated array back into the dimensions of the image
    temp=temp.reshape(height,length,pixel_data_size)

    return temp


#This is an unsafe way to generate a permutation matrix and masking matrix since it relies on the random function
#It works for demonstration purposes though
#-------------------------------------------------
#Generate a permutation matrix based upon the key
def gen_permutation(height,length,key):
    random.seed(key)
    perm=[i for i in range(0,height*length)]
    random.shuffle(perm)
    perm_map=numpy.array(perm)
    return perm_map

#Generate a masking matrix based upon the key
def gen_mask(height,length,key,pixel_data_size):
    random.seed(key)

    mask=[[0]*pixel_data_size for i in range(0,height*length)]

    for i in range(0,height*length):
        for j in range(0,pixel_data_size):
            mask[i][j]=random.randint(0,1000)

    return mask
#--------------------------------------------------

def encrypt(image,key):
    #Load in the image passed to the function as a numpy array
    image = Image.open(image)
    height,length = image.size
    image = numpy.copy(numpy.asarray(image))
    pixel_data_size=len(image[0,0])

    #Generate the permutation mapping generated by the key
    mapping=gen_permutation(height,length,key)

    #Permute the orignal image
    ciphertext=permutate(height,length,image,mapping)

    #Generate the masking generated by the key
    mask=gen_mask(height,length,key,pixel_data_size)

    #Apply the mask to the permuted image
    ciphertext=apply_mask(height,length,mask,ciphertext)

    return ciphertext

def decrypt(image,key):
    image = Image.open(image)
    height,length = image.size
    image = numpy.copy(numpy.asarray(image))
    pixel_data_size=len(image[0,0])

    #Generate the masking generated by the key
    mask=gen_mask(height,length,key,pixel_data_size)

    #Create the inverse mask
    for i in range(0,len(mask)):
        for j in range(0,pixel_data_size):
            mask[i][j]*=-1
    image=apply_mask(height,length,mask,image)

    #Generate the permutation mapping generated by the key
    mapping=gen_permutation(height,length,key)

    #Generate the inverse of the mapping matrix
    inverse_map=numpy.argsort(mapping)

    #Apply the inverse to the ciphertext
    text=permutate(height,length,image,inverse_map)


    return text

def test():
    key=11

    ciphertext=encrypt("images/100by100.png",key)
    im = Image.fromarray(numpy.uint8(ciphertext))
    # im.show()
    im.save("encrypted_test.png",quality=100)

    decrypted_message=decrypt("encrypted_test.png",key)
    im = Image.fromarray(numpy.uint8(decrypted_message))
    # im.show()
    im.save("decrypted_test.png", quality=100)

def attack(ciphertext):
    image_to_attack=Image.open(ciphertext)
    height,length = image_to_attack.size
    image_to_attack_array = numpy.copy(numpy.asarray(image_to_attack))
    pixel_data_size=len(image_to_attack_array[0,0])

    #Note that in the practical implmentation of this attack the key is not
    #known, rather the attack has access to a decryption oracle
    key=11

    #Construct (height*length)+1 chosen ciphertexts
    ciphers=[]
    temp=numpy.full((height*length,pixel_data_size),[0]*pixel_data_size, dtype=list)
    ciphers.append(temp)
    for x in range(0,height*length):
        temp=numpy.full((height*length,pixel_data_size),[0]*pixel_data_size, dtype=list)
        for y in range(0,pixel_data_size):
            temp[x][y]=255
        ciphers.append(temp)

    #Save the generated ciphertexts
    for x in range(0,len(ciphers)):
        temp=ciphers[x].reshape(height,length,pixel_data_size)
        im = Image.fromarray(numpy.uint8(temp))
        im.save(f"chosenciphers/{x}.png", quality=100)

    #Generate the corresponding plaintexts
    for x in range(0,len(ciphers)):
        temp=decrypt(f"chosenciphers/{x}.png",key)
        temp=temp.reshape(height,length,pixel_data_size)
        im = Image.fromarray(numpy.uint8(temp))
        im.save(f"plaintexts/{x}.png", quality=100)

    #Generate the differentials between the chosen ciphertexts and their decryption
    base_plaintext=Image.open(f"plaintexts/0.png")
    base_plaintext=numpy.copy(numpy.asarray(base_plaintext))
    base_plaintext=base_plaintext.reshape(height*length,pixel_data_size)

    differentials=numpy.full((height*length,height*length,pixel_data_size),[0]*pixel_data_size, dtype=list)

    for x in range(1,len(ciphers)):
        temp=Image.open(f"plaintexts/{x}.png")
        temp=numpy.copy(numpy.asarray(temp))
        temp = temp.reshape(height*length,pixel_data_size)
        differential = numpy.subtract(temp,base_plaintext)
        differentials[x-1]=differential



    #Construct the decryption matrix for the targeted ciphertext
    decryption_matrix=numpy.full((height*length,pixel_data_size),[0]*pixel_data_size)
    image_to_attack_array=image_to_attack_array.reshape(height*length,pixel_data_size)
    for x in range(0,len(differentials)):
        decryption_matrix=(decryption_matrix+(image_to_attack_array[x]*differentials[x])) % 256

    #Retrieve the ciphertext
    decrypted_image=((base_plaintext-decryption_matrix) %256)
    decrypted_image=decrypted_image.reshape(height,length,pixel_data_size)

    return decrypted_image

test()
decrypted_image=attack("encrypted_test.png")


decrypted_image = Image.fromarray(numpy.uint8(decrypted_image))
decrypted_image.show()
